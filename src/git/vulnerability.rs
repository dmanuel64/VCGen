use crate::{utils::set_optional_message, vulnerability::analyzer::StaticAnalyzer};
use git2::{Commit, Diff, Oid, Repository};
use indicatif::ProgressBar;
use regex::Regex;
use std::{
    fmt::Display,
    io::Write,
    path::{Path, PathBuf},
    process::Command,
};
use tempfile::{NamedTempFile, TempDir};

#[derive(Copy, Clone)]
pub enum VulnerableCommitIdentifier {
    STRONG,
    MEDIUM,
    LOW,
}

impl VulnerableCommitIdentifier {
    fn vulnerable_commit_regex(&self) -> Regex {
        match self {
            Self::STRONG => Regex::new(r"(?i)(denial.of.service|\bXXE\b|remote.code.execution|\bopen.redirect|OSVDB|\bvuln|\bCVE\b|\bXSS\b|\bReDoS\b|\bNVD\b|malicious|x-frame-options|attack|cross.site|exploit|directory.traversal|\bRCE\b|\bdos\b|\bXSRF\b|clickjack|session.fixation|hijack|advisory|insecure|security|\bcross-origin\b|unauthori[z|s]ed|infinite.loop)")
                .expect("Could not create regex for strong commit vulnerability identifier."),
            Self::MEDIUM => Regex::new(r"(?i)(authenticat(e|ion)|brute.force.|bypass|constant.time.|crack|credential|\bDoS\b|expos(e.|ing)|hack|harden|injection|lockout|over.flow|password.|\bPoC\b|proof.of.concept|poison|privelage.|\b(in)?secur(e|ity)|(de)?serializ|spoof|timing|traversal)")
                .expect("Could not create regex for medium commit vulnerability identifier."),
            Self::LOW => Regex::new(r"(?i)(fix)").expect("Could not create regex for low commit vulnerability identifier.")
        }
    }

    pub fn is_vulnerable_commit(&self, commit: &Commit) -> bool {
        self.vulnerable_commit_regex()
            .is_match(commit.message().unwrap_or_default())
    }
}

impl Default for VulnerableCommitIdentifier {
    fn default() -> Self {
        Self::STRONG
    }
}

pub struct VulnerableCommits {
    repo_url: String,
    repo: Repository,
    vulnerable_commit_policy: VulnerableCommitIdentifier,
}

impl VulnerableCommits {
    pub fn new(
        repo_url: &str,
        repo_dir: &TempDir,
        progress: Option<&ProgressBar>,
        vulnerable_commit_policy: Option<VulnerableCommitIdentifier>,
    ) -> Result<Self, String> {
        // clone remote repository to temp directory
        set_optional_message(
            progress,
            &format!(
                "Cloning {} to {}",
                repo_url,
                repo_dir.path().to_str().unwrap_or_default()
            ),
        );
        let repo =
            Repository::clone(repo_url, repo_dir.path()).or_else(|err| Err(err.to_string()))?;
        Ok(Self {
            repo_url: String::from(repo_url),
            repo: repo,
            vulnerable_commit_policy: vulnerable_commit_policy.unwrap_or_default(),
        })
    }

    /// Executes an arbitrary git command in the repository.
    fn arbitrary_git_command(&self, args: Vec<&str>) -> Result<String, String> {
        Command::new("git")
            .arg("-C")
            .arg(self.repo.path())
            .args(args)
            .output()
            .and_then(|results| {
                Ok(String::from_utf8(results.stdout)
                    .expect("Could not convert git command output from UTF-8."))
            })
            .or_else(|err| Err(err.to_string()))
    }

    /// Executes a `git show <commit>:<file>`, effectively getting the source code of the
    /// specified file from that commit.
    fn show_commit_file(&self, commit_hash: &Oid, commit_file: &Path) -> Result<String, String> {
        self.arbitrary_git_command(vec![
            "show",
            &format!(
                "{}:{}",
                commit_hash.to_string(),
                commit_file.to_str().unwrap()
            ),
        ])
    }

    /// Gets the diff between two commits in the repository.
    fn diff(&self, old: &Commit, new: &Commit) -> Diff {
        self.repo
            .diff_tree_to_tree(
                Some(
                    &old.tree()
                        .expect("Could not retrieve older commit tree to create diff."),
                ),
                Some(
                    &new.tree()
                        .expect("Could not retrieve newer commit tree to create diff."),
                ),
                None,
            )
            .expect("Could not create diff.")
    }

    fn repo_name(&self) -> &str {
        self.repo_url
            .split("/")
            .last()
            .unwrap_or_default()
            .split(".")
            .next()
            .unwrap_or_default()
    }

    /// Executes a function for each vulnerable commit and adds each `Ok` result to a vector of
    /// results
    fn foreach_vulnerable_commit<F, R>(
        &self,
        f: F,
        limit: Option<usize>,
        progress: Option<&ProgressBar>,
    ) -> Result<Vec<R>, String>
    where
        F: Fn(&Commit, &Commit) -> Result<R, String>,
    {
        // Traverse most recent commits from HEAD
        let mut revwalk = self.repo.revwalk().or_else(|err| Err(err.to_string()))?;
        revwalk
            .set_sorting(git2::Sort::TIME)
            .or_else(|err| Err(err.to_string()))?;
        revwalk.push_head().or_else(|err| Err(err.to_string()))?;
        // Keep track of the most prior commit traversed
        let mut prev_commit: Option<Commit> = None;
        let mut results = vec![];
        // Iterate through most recent commits
        for oid_result in revwalk {
            set_optional_message(
                progress,
                &format!("[{}] searching for vulnerable commits", self.repo_name()),
            );
            let commit = self
                .repo
                .find_commit(oid_result.or_else(|err| Err(err.to_string()))?)
                .or_else(|err| Err(err.to_string()))?;
            // Check if commit message indicates vulnerability
            if let Some(prev) = &prev_commit {
                if self.vulnerable_commit_policy.is_vulnerable_commit(&commit) {
                    if let Ok(result) = f(prev, &commit) {
                        results.push(result);
                    }
                }
            }
            prev_commit = Some(commit);
            // Check if result limit is reached
            if limit
                .and_then(|max| Some(results.len() >= max))
                .unwrap_or(false)
            {
                break;
            }
        }
        Ok(results)
    }

    pub fn vulnerable_code(
        &self,
        analyzers: &Vec<&dyn StaticAnalyzer>,
        limit: Option<usize>,
        progress: Option<&ProgressBar>,
    ) -> Result<Vec<AnalyzedFile>, String> {
        let diff_vulnerabilities = self.foreach_vulnerable_commit(
            |prev_commit, commit| {
                let mut results = vec![];
                // Get the diff of each adjacent commit
                let _diff_callback_results = self.diff(prev_commit, commit).foreach(
                    &mut |delta, _| {
                        if let Some(src_path) = delta.old_file().path() {
                            // Verify changed file is a C file
                            if src_path
                                .extension()
                                .and_then(|f| Some(f.eq("c")))
                                .unwrap_or(false)
                            {
                                // Create temporary file to write vulnerable commit
                                // source code to for analyzers
                                let mut tempfile =
                                    NamedTempFile::new().expect("Could not create tempfile to store potential vulnerable source code.");
                                let src_code = self
                                    .show_commit_file(&prev_commit.id(), &src_path)
                                    .expect("Could not get potential vulnerable source code.");
                                write!(tempfile, "{}", src_code)
                                    .expect("Could not write potential vulnerable source code to tempfile.");
                                set_optional_message(
                                    progress,
                                    &format!("[{}] scanning {}", self.repo_name(), src_path.file_name().unwrap_or_default().to_str().unwrap_or_default()),
                                );
                                // Run vulnerability tools
                                let analyzed_file = AnalyzedFile::new(
                                    &self.repo_url,
                                    &prev_commit.id(),
                                    delta.old_file().path().expect("Could not get path of local repository file."),
                                    tempfile.path(),
                                    &src_code,
                                    VulnerabilityType::ADDRESSED,
                                    analyzers,
                                );
                                // Delete temporary file containing source code for analyzers
                                tempfile.close().expect("Could not close temporary file containing potentially vulnerable source code.");
                                // Add to list of vulnerabilities if any were reported
                                if analyzed_file.is_vulnerable() {
                                    results.push(analyzed_file);
                                    if let Some(pb) = progress {
                                        pb.inc(1);
                                    }
                                    // Stop searching if quota has been reached
                                    if limit.and_then(|max| Some(results.len() > max)).unwrap_or(false) {
                                        return false;
                                    }
                                }
                            }
                        }
                        true
                    },
                    None,
                    None,
                    None,
                );
                if results.len() > 0 { Ok(results) } else { Err(String::from("No results")) }
            },
            limit,
            progress
        )?;
        Ok(diff_vulnerabilities.concat())
    }

    pub fn vulnerable_commits(&self, progress: Option<&ProgressBar>) -> Vec<String> {
        self.foreach_vulnerable_commit(
            |prev_commit, _| Ok(prev_commit.id().to_string()),
            None,
            progress,
        )
        .expect("Could not retrieve vulnerable commits.")
    }
}

#[derive(Debug)]
pub enum VulnerabilityType {
    ADDRESSED,
    INTRODUCED,
}

impl Clone for VulnerabilityType {
    fn clone(&self) -> Self {
        match self {
            Self::ADDRESSED => Self::ADDRESSED,
            Self::INTRODUCED => Self::INTRODUCED,
        }
    }
}

impl Display for VulnerabilityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Clone)]
pub struct AnalyzedFile {
    repo_url: String,
    commit_hash: String,
    repo_file_path: PathBuf,
    code: String,
    kind: VulnerabilityType,
    flawfinder_results: Option<Vec<String>>,
    flawfinder_cwes: Option<Vec<String>>,
}

impl AnalyzedFile {
    pub fn new(
        repo_url: &str,
        commit_hash: &Oid,
        repo_file_path: &Path,
        tempfile_path: &Path,
        code: &str,
        kind: VulnerabilityType,
        analyzers: &Vec<&dyn StaticAnalyzer>,
    ) -> Self {
        let mut flawfinder_results = None;
        let mut flawfinder_cwes = None;
        for analyzer in analyzers {
            match analyzer.name() {
                "Flawfinder" => {
                    flawfinder_results =
                        Self::non_empty_vec(analyzer.vulnerabilities(tempfile_path));
                    flawfinder_cwes = Self::non_empty_vec(analyzer.cwes(tempfile_path));
                }
                unknown => panic!(
                    "Cannot analyze source file with unknown static analyzer: {}",
                    unknown
                ),
            }
        }
        Self {
            repo_url: String::from(repo_url),
            commit_hash: commit_hash.to_string(),
            repo_file_path: PathBuf::from(repo_file_path),
            code: String::from(code),
            kind: kind,
            flawfinder_results: flawfinder_results,
            flawfinder_cwes: flawfinder_cwes,
        }
    }

    fn non_empty_vec<T>(v: Vec<T>) -> Option<Vec<T>> {
        if v.len() > 0 {
            Some(v)
        } else {
            None
        }
    }

    pub fn is_vulnerable(&self) -> bool {
        [&self.flawfinder_results]
            .iter()
            .any(|tool_result| tool_result.is_some())
    }

    pub fn repo_url(&self) -> &str {
        self.repo_url.as_ref()
    }

    pub fn commit_hash(&self) -> &str {
        self.commit_hash.as_ref()
    }

    pub fn repo_file_path(&self) -> &PathBuf {
        &self.repo_file_path
    }

    pub fn code(&self) -> &str {
        self.code.as_ref()
    }

    pub fn kind(&self) -> &VulnerabilityType {
        &self.kind
    }

    pub fn flawfinder_results(&self) -> Option<&Vec<String>> {
        self.flawfinder_results.as_ref()
    }

    pub fn flawfinder_cwes(&self) -> Option<&Vec<String>> {
        self.flawfinder_cwes.as_ref()
    }
}
