use std::{collections::HashMap, path::PathBuf, process::Command, thread::sleep};

use crate::vulnerability::analyzer::StaticAnalyzer;
use git2::{Commit, Repository};
use indicatif::ProgressBar;
use regex::Regex;
use tempfile::TempDir;

pub struct VulnerableCommits<'a> {
    repo_url: String,
    repo_dir: &'a TempDir,
    repo: Repository,
}

impl<'a> VulnerableCommits<'a> {
    pub fn new(
        repo_url: &str,
        repo_dir: &'a TempDir,
        progress: Option<&ProgressBar>,
    ) -> Result<Self, String> {
        if let Some(pb) = progress {
            pb.set_message(format!(
                "Cloning {} to {}",
                repo_url,
                repo_dir.path().as_os_str().to_str().unwrap()
            ));
            pb.enable_steady_tick(1000);
        }
        let repo =
            Repository::clone(repo_url, repo_dir.path()).or_else(|err| Err(err.to_string()))?;
        if let Some(pb) = progress {
            pb.disable_steady_tick();
        }
        Ok(Self {
            repo_url: String::from(repo_url),
            repo_dir: repo_dir,
            repo: repo,
        })
    }

    fn is_vulnerable_commit(commit: &Commit) -> bool {
        Regex::new(r"(?i)(denial.of.service|\bXXE\b|remote.code.execution|\bopen.redirect|OSVDB|\bvuln|\bCVE\b
            |\bXSS\b|\bReDoS\b|\bNVD\b|malicious|x-frame-options|attack|cross.site|exploit|directory.
            traversal|fix|\bRCE\b|\bdos\b|\bXSRF\b|clickjack|session.fixation|hijack|advisory|insecure|security|\bcross-origin\b|unauthori[z|s]ed|infinite.loop)")
            .expect("Could not create commit vulnerability regex")
            .is_match(commit.message().unwrap_or_else(|| ""))
    }

    fn arbitrary_git_command(&self, args: Vec<&str>) -> Result<String, String> {
        Command::new("git")
            .arg("-C")
            .arg(self.repo.path())
            .args(args)
            .output()
            .and_then(|results| {
                Ok(String::from_utf8(results.stdout).expect("Could not convert from UTF-8"))
            })
            .or_else(|err| Err(err.to_string()))
    }

    pub fn vulnerable_commits(
        &self,
        progress: Option<&ProgressBar>,
    ) -> Result<Vec<Commit>, String> {
        let revwalk = self.repo.revwalk().or_else(|err| Err(err.to_string()))?;
        let mut vulnerable_commits = vec![];
        let mut prev_commit: Option<Commit> = None;
        if let Some(pb) = progress {
            pb.set_message(format!(
                "{}: Searching for vulnerable commits",
                self.repo.namespace().unwrap_or_else(|| "[UNKNOWN REPO]")
            ));
        }
        for oid_result in revwalk {
            let commit = self
                .repo
                .find_commit(oid_result.or_else(|err| Err(err.to_string()))?)
                .or_else(|err| Err(err.to_string()))?;
            if prev_commit.is_some() && Self::is_vulnerable_commit(&commit) {
                vulnerable_commits.push(prev_commit.unwrap());
            }
            prev_commit = Some(commit);
        }
        Ok(vulnerable_commits)
    }

    pub fn vulnerable_code(
        &self,
        analyzers: Vec<Box<dyn StaticAnalyzer>>,
        max: Option<i32>,
        progress: Option<&ProgressBar>,
    ) -> Result<Vec<VulnerableCode>, String> {
        let mut revwalk = self.repo.revwalk().or_else(|err| Err(err.to_string()))?;
        revwalk
            .set_sorting(git2::Sort::TIME)
            .or_else(|err| Err(err.to_string()))?;
        revwalk.push_head().or_else(|err| Err(err.to_string()))?;
        let mut prev_commit: Option<Commit> = None;
        let mut vulnerable_code = vec![];
        if let Some(pb) = progress {
            pb.set_message(format!(
                "{}: Searching for vulnerable commits",
                self.repo.namespace().unwrap_or_else(|| "[UNKNOWN REPO]")
            ));
        }
        for oid_result in revwalk {
            // sleep(core::time::Duration::from_millis(1000 * 15));
            let commit = self
                .repo
                .find_commit(oid_result.or_else(|err| Err(err.to_string()))?)
                .or_else(|err| Err(err.to_string()))?;
            if prev_commit.is_some() && Self::is_vulnerable_commit(&commit) {
                // sleep(core::time::Duration::from_millis(1000 * 15));
                if let Some(pb) = progress {
                    pb.set_message(format!(
                        "{}: Searching for vulnerable code",
                        self.repo.namespace().unwrap_or_else(|| "[UNKNOWN REPO]")
                    ));
                }
                let prev_tree = prev_commit
                    .unwrap()
                    .tree()
                    .or_else(|err| Err(err.to_string()))?;
                let tree = commit.tree().or_else(|err| Err(err.to_string()))?;
                self.repo
                    .diff_tree_to_tree(Some(&prev_tree), Some(&tree), None)
                    .expect("Couldn't unwrap tree")
                    .foreach(
                        &mut |diff, _| {
                            format!(
                                "{}:{}",
                                prev_tree.id().to_string(),
                                diff.old_file().path().unwrap().to_str().unwrap()
                            );
                            if let Some(src_path) = diff.old_file().path() {
                                if src_path
                                    .extension()
                                    .and_then(|f| Some(f.eq("c")))
                                    .unwrap_or(false)
                                {
                                    if let Ok(src) = self.arbitrary_git_command(vec![
                                        "show",
                                        &format!(
                                            "{}:{}",
                                            prev_tree.id().to_string(),
                                            diff.old_file().path().unwrap().to_str().unwrap()
                                        ),
                                    ]) {
                                        panic!("{}", src);
                                    }
                                }
                            }
                            true
                        },
                        None,
                        None,
                        None,
                    )
                    .or_else(|err| Err(err.to_string()))?;
            }
            prev_commit = Some(commit);
        }
        Ok(vulnerable_code)
    }

    pub fn vulnerable_code2(
        &self,
        analyzers: Vec<Box<dyn StaticAnalyzer>>,
        max: Option<i32>,
        progress: Option<&ProgressBar>,
    ) -> Result<Vec<String>, String> {
        let vulnerable_commits = self.vulnerable_commits(progress)?;
        let mut vulnerable_code = vec![];
        if let Some(pb) = progress {
            pb.set_message(format!(
                "{}: Searching for vulnerable code",
                self.repo.namespace().unwrap_or_else(|| "[UNKNOWN REPO]")
            ));
        }
        for commit in vulnerable_commits {
            self.repo
                .checkout_tree(commit.as_object(), None)
                .or_else(|err| Err(err.to_string()))?;
            self.repo
                .diff_index_to_workdir(None, None)
                .unwrap()
                .foreach(&mut |diff, f| true, None, None, None);
            vulnerable_code.push(format!("1"));
            if let Some(pb) = progress {
                pb.inc(1);
            }
            if let Some(limit) = max {
                if limit as usize >= vulnerable_code.len() {
                    break;
                }
            }
        }
        Ok(vulnerable_code)
    }
}

pub enum VulnerabilityType {
    ADDRESSED,
    INTRODUCED,
}

pub struct VulnerableCode {
    file_path: PathBuf,
    kind: VulnerabilityType,
    results: HashMap<Box<dyn StaticAnalyzer>, Vec<String>>,
}

impl VulnerableCode {}
