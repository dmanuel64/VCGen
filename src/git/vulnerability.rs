use crate::vulnerability::analyzer::StaticAnalyzer;
use git2::{Commit, Repository};
use indicatif::ProgressBar;
use regex::Regex;
use tempfile::{tempdir, TempDir};

pub struct VulnerableCommits {
    repo_url: String,
    repo_dir: TempDir,
    repo: Repository,
}

impl VulnerableCommits {
    pub fn new(repo_url: &str, progress: Option<&ProgressBar>) -> Result<Self, String> {
        let tempdir = tempdir().or_else(|err| Err(err.to_string()))?;
        progress.and_then(|pb| {
            Some(pb.set_message(format!(
                "Cloning {} to {}",
                repo_url,
                tempdir.path().as_os_str().to_str().unwrap()
            )))
        });
        let repo =
            Repository::clone(repo_url, tempdir.path()).or_else(|err| Err(err.to_string()))?;
        Ok(Self {
            repo_url: String::from(repo_url),
            repo_dir: tempdir,
            repo: repo,
        })
    }

    pub fn vulnerable_commits(
        &self,
        progress: Option<&ProgressBar>,
    ) -> Result<Vec<Commit>, String> {
        let revwalk = self.repo.revwalk().or_else(|err| Err(err.to_string()))?;
        let mut vulnerable_commits = vec![];
        let vulnerability_regex =
            Regex::new(r"(?i)(denial.of.service |\bXXE\b|remote.code.execution|\bopen.redirect|OSVDB|\bvuln|\bCVE\b
                |\bXSS\b|\bReDoS\b|\bNVD\b|malicious|x-frame-options|attack|cross.site|exploit|directory.
                traversal|\bRCE\b|\bdos\b|\bXSRF\b|clickjack|session.fixation|hijack|advisory|insecure|security|\bcross-origin\b|unauthori[z|s]ed|infinite.loop)").or_else(|err| Err(err.to_string()))?;
        let mut prev_commit: Option<Commit> = None;
        if let Some(pb) = progress {
            pb.set_message(format!(
                "{}: Searching for vulnerable commits",
                self.repo.namespace().unwrap_or_else(|| "[UNKNOWN REPO]")
            ));
        }
        for oid_result in revwalk {
            let commit = self
                .repo
                .find_commit(oid_result.or_else(|err| Err(err.to_string()))?)
                .or_else(|err| Err(err.to_string()))?;
            if prev_commit.is_some()
                && vulnerability_regex
                    .is_match(commit.message().ok_or("Could not get commit message")?)
            {
                vulnerable_commits.push(prev_commit.unwrap());
            }
            prev_commit = Some(commit);
        }
        Ok(vulnerable_commits)
    }

    pub fn vulnerable_code(
        &self,
        analyzers: Vec<Box<dyn StaticAnalyzer>>,
        max: Option<i32>,
        progress: Option<&ProgressBar>,
    ) -> Result<Vec<String>, String> {
        let vulnerable_commits = self.vulnerable_commits(progress)?;
        let mut vulnerable_code = vec![];
        if let Some(pb) = progress {
            pb.set_message(format!(
                "{}: Searching for vulnerable code",
                self.repo.namespace().unwrap_or_else(|| "[UNKNOWN REPO]")
            ));
        }
        for commit in vulnerable_commits {
            self.repo
                .checkout_tree(commit.as_object(), None)
                .or_else(|err| Err(err.to_string()))?;
            
            vulnerable_code.push(format!("1"));
            if let Some(pb) = progress {
                pb.inc(1);
            }
            if let Some(limit) = max {
                if limit as usize >= vulnerable_code.len() {
                    break;
                }
            }
        }
        Ok(vulnerable_code)
    }
}
