use crate::vulnerability::analyzer::StaticAnalyzer;
use git2::{Commit, Oid, Repository};
use indicatif::ProgressBar;
use regex::Regex;
use std::{
    fmt::Display,
    fs::read_to_string,
    io::Write,
    path::{Path, PathBuf},
    process::Command,
};
use tempfile::{NamedTempFile, TempDir};

pub struct VulnerableCommits<'a> {
    repo_url: String,
    repo_dir: &'a TempDir,
    repo: Repository,
}

impl<'a> VulnerableCommits<'a> {
    pub fn new(
        repo_url: &str,
        repo_dir: &'a TempDir,
        progress: Option<&ProgressBar>,
    ) -> Result<Self, String> {
        if let Some(pb) = progress {
            pb.set_message(format!(
                "Cloning {} to {}",
                repo_url,
                repo_dir.path().as_os_str().to_str().unwrap()
            ));
        }
        let repo =
            Repository::clone(repo_url, repo_dir.path()).or_else(|err| Err(err.to_string()))?;
        Ok(Self {
            repo_url: String::from(repo_url),
            repo_dir: repo_dir,
            repo: repo,
        })
    }

    fn is_vulnerable_commit(commit: &Commit) -> bool {
        Regex::new(r"(?i)(denial.of.service|\bXXE\b|remote.code.execution|\bopen.redirect|OSVDB|\bvuln|\bCVE\b
            |\bXSS\b|\bReDoS\b|\bNVD\b|malicious|x-frame-options|attack|cross.site|exploit|directory.
            traversal|fix|\bRCE\b|\bdos\b|\bXSRF\b|clickjack|session.fixation|hijack|advisory|insecure|security|\bcross-origin\b|unauthori[z|s]ed|infinite.loop)")
            .expect("Could not create commit vulnerability regex")
            .is_match(commit.message().unwrap_or_else(|| ""))
    }

    fn arbitrary_git_command(&self, args: Vec<&str>) -> Result<String, String> {
        Command::new("git")
            .arg("-C")
            .arg(self.repo.path())
            .args(args)
            .output()
            .and_then(|results| {
                Ok(String::from_utf8(results.stdout).expect("Could not convert from UTF-8"))
            })
            .or_else(|err| Err(err.to_string()))
    }

    fn save_commit_file(&self, commit_hash: &Oid, commit_file: &Path) -> Result<String, String> {
        self.arbitrary_git_command(vec![
            "show",
            &format!(
                "{}:{}",
                commit_hash.to_string(),
                commit_file.to_str().unwrap()
            ),
        ])
    }
    pub fn vulnerable_code(
        &self,
        analyzers: Vec<Box<dyn StaticAnalyzer>>,
        max: Option<i32>,
        progress: Option<&ProgressBar>,
    ) -> Result<Vec<VulnerableCode>, String> {
        // Traverse most recent commits from HEAD
        let mut revwalk = self.repo.revwalk().or_else(|err| Err(err.to_string()))?;
        revwalk
            .set_sorting(git2::Sort::TIME)
            .or_else(|err| Err(err.to_string()))?;
        revwalk.push_head().or_else(|err| Err(err.to_string()))?;
        let mut prev_commit: Option<Commit> = None;
        let mut vulnerable_code = vec![];
        if let Some(pb) = progress {
            pb.set_message(format!(
                "{}: Searching for vulnerable commits",
                self.repo.namespace().unwrap_or_else(|| "[UNKNOWN REPO]")
            ));
        }
        // Iterate through most recent commits
        for oid_result in revwalk {
            let commit = self
                .repo
                .find_commit(oid_result.or_else(|err| Err(err.to_string()))?)
                .or_else(|err| Err(err.to_string()))?;
            // Check if commit message indicates vulnerability
            if prev_commit.is_some() && Self::is_vulnerable_commit(&commit) {
                // sleep(core::time::Duration::from_millis(1000 * 15));
                if let Some(pb) = progress {
                    pb.set_message(format!(
                        "{}: Searching for vulnerable code",
                        self.repo.namespace().unwrap_or_else(|| "[UNKNOWN REPO]")
                    ));
                }
                // Get diff from potential vulnerable commit and previous commit and for each file change,
                // run vulnerability tools
                let prev_tree = prev_commit
                    .unwrap()
                    .tree()
                    .or_else(|err| Err(err.to_string()))?;
                let tree = commit.tree().or_else(|err| Err(err.to_string()))?;
                self.repo
                    .diff_tree_to_tree(Some(&prev_tree), Some(&tree), None)
                    .expect("Couldn't unwrap tree")
                    .foreach(
                        &mut |diff, _| {
                            if let Some(src_path) = diff.old_file().path() {
                                // Verify changed file is a C file
                                if src_path
                                    .extension()
                                    .and_then(|f| Some(f.eq("c")))
                                    .unwrap_or(false)
                                {
                                    // Create temporary file to write vulnerable commit
                                    // source code to
                                    let mut src_file =
                                        NamedTempFile::new().expect("Could not create tempfile");
                                    let src_code = self
                                        .save_commit_file(&prev_tree.id(), &src_path)
                                        .expect("Could not save source file");
                                    write!(src_file, "{}", src_code)
                                        .expect("Could not write to tempfile.");
                                    // Run vulnerability tools
                                    let mut ac = AnalyzedCode::new(
                                        &self.repo_url,
                                        &diff.old_file().id().to_string(),
                                        diff.old_file().path().expect("Missing path"),
                                        &read_to_string(&src_file).expect(&format!(
                                            "Could not read code from {}",
                                            &src_file.path().to_str().unwrap()
                                        )),
                                        VulnerabilityType::ADDRESSED,
                                    );
                                    for tool in &analyzers {
                                        if let "Flawfinder" = tool.name().as_str() {
                                            ac.set_flawfinder_results(
                                                tool.vulnerabilities(src_file.path()),
                                            );
                                            ac.set_flawfinder_cwes(tool.cwes(src_file.path()));
                                        } else {
                                            panic!("Unknown tool: {}", tool.name());
                                        }
                                    }
                                    src_file.close();
                                    // Add to list of vulnerabilities if any were reported
                                    if ac.is_vulnerable() {
                                        if let Some(pb) = progress {
                                            pb.inc(1);
                                        }
                                        vulnerable_code.push(ac);
                                        if let Some(limit) = max {
                                            if vulnerable_code.len() >= limit as usize {
                                                return true;
                                            }
                                        }
                                    }
                                }
                            }
                            true
                        },
                        None,
                        None,
                        None,
                    )
                    .or_else(|err| Err(err.to_string()))?;
            }
            prev_commit = Some(commit);
            if let Some(limit) = max {
                if vulnerable_code.len() >= limit as usize {
                    break;
                }
            }
        }
        Ok(vulnerable_code)
    }
}

#[derive(Debug)]
pub enum VulnerabilityType {
    ADDRESSED,
    INTRODUCED,
}

impl Display for VulnerabilityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

pub struct AnalyzedCode {
    repo_url: String,
    commit_hash: String,
    file_path: PathBuf,
    code: String,
    kind: VulnerabilityType,
    flawfinder_results: Option<Vec<String>>,
    flawfinder_cwes: Option<Vec<String>>,
}

impl AnalyzedCode {
    pub fn new(
        repo_url: &str,
        commit_hash: &str,
        file_path: &Path,
        code: &str,
        kind: VulnerabilityType,
    ) -> AnalyzedCode {
        AnalyzedCode {
            repo_url: String::from(repo_url),
            commit_hash: String::from(commit_hash),
            file_path: PathBuf::from(file_path),
            code: String::from(code),
            kind: kind,
            flawfinder_results: None,
            flawfinder_cwes: None,
        }
    }

    pub fn file_path(&self) -> &PathBuf {
        &self.file_path
    }

    pub fn kind(&self) -> &VulnerabilityType {
        &self.kind
    }

    pub fn flawfinder_results(&self) -> Option<&Vec<String>> {
        self.flawfinder_results.as_ref()
    }

    pub fn set_flawfinder_results(&mut self, flawfinder_results: Vec<String>) {
        if !flawfinder_results.is_empty() {
            self.flawfinder_results = Some(flawfinder_results);
        }
    }

    pub fn is_vulnerable(&self) -> bool {
        [&self.flawfinder_results]
            .iter()
            .any(|tool_result| tool_result.is_some())
    }

    pub fn repo_url(&self) -> &str {
        self.repo_url.as_ref()
    }

    pub fn flawfinder_cwes(&self) -> Option<&Vec<String>> {
        self.flawfinder_cwes.as_ref()
    }

    pub fn set_flawfinder_cwes(&mut self, flawfinder_cwes: Vec<String>) {
        if !flawfinder_cwes.is_empty() {
            self.flawfinder_cwes = Some(flawfinder_cwes);
        }
    }

    pub fn code(&self) -> &str {
        self.code.as_ref()
    }

    pub fn commit_hash(&self) -> &str {
        self.commit_hash.as_ref()
    }
}

impl Default for AnalyzedCode {
    fn default() -> Self {
        Self {
            repo_url: String::from("https://github.com/test"),
            commit_hash: String::from("abcd1234"),
            file_path: PathBuf::from("main.c"),
            code: String::from(
                "int main(char **args) {
                    printf(\"Hello, world.\");
            }",
            ),
            kind: VulnerabilityType::ADDRESSED,
            flawfinder_results: Some(vec![
                String::from("Error: test123"),
                String::from("Error: testabc"),
            ]),
            flawfinder_cwes: None,
        }
    }
}

pub type VulnerableCode = AnalyzedCode;
