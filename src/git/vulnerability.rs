use std::{fs::remove_dir_all, process::exit};

use crate::vulnerability::analyzer::StaticAnalyzer;
use git2::{Commit, Repository};
use indicatif::ProgressBar;
use regex::Regex;
use tempfile::{tempdir, TempDir};

pub struct VulnerableCommits<'a> {
    repo_url: String,
    repo_dir: &'a TempDir,
    repo: Repository,
}

impl<'a> VulnerableCommits<'a> {
    pub fn new(repo_url: &str, repo_dir: &'a TempDir, progress: Option<&ProgressBar>) -> Result<Self, String> {
        //let tempdir = tempdir().or_else(|err| Err(err.to_string()))?;
        if let Some(pb) = progress {
            pb.set_message(format!(
                "Cloning {} to {}",
                repo_url,
                repo_dir.path().as_os_str().to_str().unwrap()
            ));
            pb.enable_steady_tick(1000);
        }
        let repo =
            Repository::clone(repo_url, repo_dir.path()).or_else(|err| Err(err.to_string()))?;
        if let Some(pb) = progress {
            pb.disable_steady_tick();
        }
        Ok(Self {
            repo_url: String::from(repo_url),
            repo_dir: repo_dir,
            repo: repo,
        })
    }

    fn is_vulnerable_commit(commit: &Commit) -> bool {
        Regex::new(r"(?i)(denial.of.service |\bXXE\b|remote.code.execution|\bopen.redirect|OSVDB|\bvuln|\bCVE\b
            |\bXSS\b|\bReDoS\b|\bNVD\b|malicious|x-frame-options|attack|cross.site|exploit|directory.
            traversal|\bRCE\b|\bdos\b|\bXSRF\b|clickjack|session.fixation|hijack|advisory|insecure|security|\bcross-origin\b|unauthori[z|s]ed|infinite.loop)")
            .expect("Could not create commit vulnerability regex")
            .is_match(commit.message().unwrap_or_else(|| ""))
    }

    pub fn vulnerable_commits(
        &self,
        progress: Option<&ProgressBar>,
    ) -> Result<Vec<Commit>, String> {
        let revwalk = self.repo.revwalk().or_else(|err| Err(err.to_string()))?;
        let mut vulnerable_commits = vec![];
        let mut prev_commit: Option<Commit> = None;
        if let Some(pb) = progress {
            pb.set_message(format!(
                "{}: Searching for vulnerable commits",
                self.repo.namespace().unwrap_or_else(|| "[UNKNOWN REPO]")
            ));
        }
        for oid_result in revwalk {
            let commit = self
                .repo
                .find_commit(oid_result.or_else(|err| Err(err.to_string()))?)
                .or_else(|err| Err(err.to_string()))?;
            if prev_commit.is_some() && Self::is_vulnerable_commit(&commit) {
                vulnerable_commits.push(prev_commit.unwrap());
            }
            prev_commit = Some(commit);
        }
        Ok(vulnerable_commits)
    }

    pub fn vulnerable_code(
        &self,
        analyzers: Vec<Box<dyn StaticAnalyzer>>,
        max: Option<i32>,
        progress: Option<&ProgressBar>,
    ) -> Result<Vec<String>, String> {
        let vulnerable_commits = self.vulnerable_commits(progress)?;
        let mut vulnerable_code = vec![];
        if let Some(pb) = progress {
            pb.set_message(format!(
                "{}: Searching for vulnerable code",
                self.repo.namespace().unwrap_or_else(|| "[UNKNOWN REPO]")
            ));
        }
        for commit in vulnerable_commits {
            self.repo
                .checkout_tree(commit.as_object(), None)
                .or_else(|err| Err(err.to_string()))?;

            vulnerable_code.push(format!("1"));
            if let Some(pb) = progress {
                pb.inc(1);
            }
            if let Some(limit) = max {
                if limit as usize >= vulnerable_code.len() {
                    break;
                }
            }
        }
        Ok(vulnerable_code)
    }
}
